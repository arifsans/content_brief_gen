import 'dart:io';
import 'dart:typed_data';
import 'package:archive/archive.dart';
import 'ai_provider.dart';

/// Word Document Generator for Content Briefs
class WordDocumentGenerator {
  
  /// Generate a Word document for the content brief
  Future<void> generateWordDocument(ContentBrief brief, {String? outputDir, String? timestampedFolder}) async {
    final dir = timestampedFolder != null 
        ? 'results/$timestampedFolder' 
        : (outputDir ?? 'content_briefs');
    final briefDir = Directory(dir);
    if (!await briefDir.exists()) {
      await briefDir.create(recursive: true);
    }

    final safeKeyword = brief.keyword.replaceAll(RegExp(r'[^\w\s-]'), '').trim();
    final filename = '$dir/${safeKeyword.replaceAll(' ', '_')}_brief.docx';
    
    // Create the Word document content
    final wordContent = _createWordDocument(brief);
    
    // Create the DOCX file
    final archive = Archive();
    
    // Add required files for DOCX format
    _addDocxFiles(archive, wordContent);
    
    // Encode and save
    final encoder = ZipEncoder();
    final data = encoder.encode(archive);
    
    await File(filename).writeAsBytes(data!);
    print('ðŸ“„ Word document saved to: $filename');
  }

  /// Create the main document content XML
  String _createWordDocument(ContentBrief brief) {
    final content = StringBuffer();
    
    // Document header
    content.write('''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
  <w:body>
''');

    // Title
    content.write(_createHeading('SEO CONTENT BRIEF', 1));
    content.write(_createParagraph('Generated on: ${_formatDateTime(brief.generatedAt)}'));
    content.write(_createParagraph(''));

    // Primary Keyword Section
    content.write(_createHeading('PRIMARY KEYWORD', 2));
    content.write(_createParagraph(brief.keyword, bold: true));
    content.write(_createParagraph(''));

    // Topic Section
    content.write(_createHeading('TOPIC', 2));
    content.write(_createParagraph(brief.topic));
    content.write(_createParagraph(''));

    // SEO Title Section
    content.write(_createHeading('SEO TITLE', 2));
    content.write(_createParagraph(brief.title, bold: true));
    content.write(_createParagraph('Characters: ${brief.title.length}', italic: true));
    content.write(_createParagraph(''));

    // Meta Description Section
    content.write(_createHeading('META DESCRIPTION', 2));
    content.write(_createParagraph(brief.metaDescription));
    content.write(_createParagraph('Characters: ${brief.metaDescription.length}', italic: true));
    content.write(_createParagraph(''));

    // Article Structure Section
    content.write(_createHeading('ARTICLE STRUCTURE', 2));
    for (var i = 0; i < brief.articleStructure.length; i++) {
      content.write(_createParagraph('${brief.articleStructure[i]}'));
    }
    content.write(_createParagraph(''));

    // Related Keywords Section
    content.write(_createHeading('RELATED KEYWORDS', 2));
    final keywordChunks = <String>[];
    for (var i = 0; i < brief.relatedKeywords.length; i += 3) {
      final chunk = brief.relatedKeywords.skip(i).take(3).join(' â€¢ ');
      keywordChunks.add(chunk);
    }
    for (final chunk in keywordChunks) {
      content.write(_createParagraph(chunk));
    }
    content.write(_createParagraph(''));

    // Footer
    content.write(_createParagraph('Generated by Enhanced SEO Content Brief Generator', italic: true));
    content.write(_createParagraph('Powered by OpenAI GPT', italic: true));

    // Document footer
    content.write('''
  </w:body>
</w:document>''');

    return content.toString();
  }

  /// Create a heading in Word format
  String _createHeading(String text, int level) {
    return '''
    <w:p>
      <w:pPr>
        <w:pStyle w:val="Heading$level"/>
      </w:pPr>
      <w:r>
        <w:t>$text</w:t>
      </w:r>
    </w:p>
''';
  }

  /// Create a paragraph in Word format
  String _createParagraph(String text, {bool bold = false, bool italic = false}) {
    final runProps = StringBuffer();
    if (bold || italic) {
      runProps.write('<w:rPr>');
      if (bold) runProps.write('<w:b/>');
      if (italic) runProps.write('<w:i/>');
      runProps.write('</w:rPr>');
    }

    return '''
    <w:p>
      <w:r>
        $runProps
        <w:t>${_escapeXml(text)}</w:t>
      </w:r>
    </w:p>
''';
  }

  /// Add required files for DOCX format
  void _addDocxFiles(Archive archive, String documentContent) {
    // Add [Content_Types].xml
    archive.addFile(ArchiveFile(
      '[Content_Types].xml',
      0,
      Uint8List.fromList(_contentTypesXml.codeUnits),
    ));

    // Add _rels/.rels
    archive.addFile(ArchiveFile(
      '_rels/.rels',
      0,
      Uint8List.fromList(_relsXml.codeUnits),
    ));

    // Add word/_rels/document.xml.rels
    archive.addFile(ArchiveFile(
      'word/_rels/document.xml.rels',
      0,
      Uint8List.fromList(_documentRelsXml.codeUnits),
    ));

    // Add word/document.xml (main content)
    archive.addFile(ArchiveFile(
      'word/document.xml',
      0,
      Uint8List.fromList(documentContent.codeUnits),
    ));

    // Add word/styles.xml
    archive.addFile(ArchiveFile(
      'word/styles.xml',
      0,
      Uint8List.fromList(_stylesXml.codeUnits),
    ));
  }

  /// Escape XML special characters
  String _escapeXml(String text) {
    return text
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#39;');
  }

  String _formatDateTime(DateTime dateTime) {
    final months = [
      '', 'Januari', 'Februari', 'Maret', 'April', 'Mei', 'Juni',
      'Juli', 'Agustus', 'September', 'Oktober', 'November', 'Desember'
    ];
    
    final day = dateTime.day.toString().padLeft(2, '0');
    final month = months[dateTime.month];
    final year = dateTime.year.toString();
    final hour = dateTime.hour.toString().padLeft(2, '0');
    final minute = dateTime.minute.toString().padLeft(2, '0');
    
    return '$day-$month-$year $hour:$minute';
  }

  // Required DOCX file contents
  static const String _contentTypesXml = '''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
  <Default Extension="xml" ContentType="application/xml"/>
  <Override PartName="/word/document.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/>
  <Override PartName="/word/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml"/>
</Types>''';

  static const String _relsXml = '''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="word/document.xml"/>
</Relationships>''';

  static const String _documentRelsXml = '''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/>
</Relationships>''';

  static const String _stylesXml = '''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:styles xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
  <w:style w:type="paragraph" w:styleId="Heading1">
    <w:name w:val="heading 1"/>
    <w:pPr>
      <w:spacing w:after="240"/>
    </w:pPr>
    <w:rPr>
      <w:b/>
      <w:sz w:val="32"/>
    </w:rPr>
  </w:style>
  <w:style w:type="paragraph" w:styleId="Heading2">
    <w:name w:val="heading 2"/>
    <w:pPr>
      <w:spacing w:after="240"/>
    </w:pPr>
    <w:rPr>
      <w:b/>
      <w:sz w:val="24"/>
    </w:rPr>
  </w:style>
</w:styles>''';
}